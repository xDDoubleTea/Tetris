.\" Automatically generated by Pandoc 3.1.12.1
.\"
.TH "al_init_user_event_source" "3" "" "Allegro reference manual" ""
.SH NAME
al_init_user_event_source \- Allegro 5 API
.SH SYNOPSIS
.IP
.EX
#include \f[B]<allegro5/allegro.h>\f[R]

void al_init_user_event_source(ALLEGRO_EVENT_SOURCE *src)
.EE
.SH DESCRIPTION
Initialise an event source for emitting user events.
The space for the event source must already have been allocated.
.PP
One possible way of creating custom event sources is to derive other
structures with ALLEGRO_EVENT_SOURCE at the head, e.g.
.IP
.EX
\f[B]typedef\f[R] \f[B]struct\f[R] THING THING;

\f[B]struct\f[R] THING {
    ALLEGRO_EVENT_SOURCE event_source;
    int field1;
    int field2;
    \f[I]/* etc. */\f[R]
};

THING *create_thing(void)
{
    THING *thing = malloc(\f[B]sizeof\f[R](THING));

    \f[B]if\f[R] (thing) {
        al_init_user_event_source(&thing\->event_source);
        thing\->field1 = 0;
        thing\->field2 = 0;
    }

    \f[B]return\f[R] thing;
}
.EE
.PP
The advantage here is that the THING pointer will be the same as the
ALLEGRO_EVENT_SOURCE pointer.
Events emitted by the event source will have the event source pointer as
the \f[CR]source\f[R] field, from which you can get a pointer to a THING
by a simple cast (after ensuring checking the event is of the correct
type).
.PP
However, it is only one technique and you are not obliged to use it.
.PP
The user event source will never be destroyed automatically.
You must destroy it manually with al_destroy_user_event_source(3).
.SH SEE ALSO
ALLEGRO_EVENT_SOURCE(3), al_destroy_user_event_source(3),
al_emit_user_event(3), ALLEGRO_USER_EVENT(3)
