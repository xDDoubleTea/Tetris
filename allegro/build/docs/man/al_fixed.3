.\" Automatically generated by Pandoc 3.1.12.1
.\"
.TH "al_fixed" "3" "" "Allegro reference manual" ""
.SH NAME
al_fixed \- Allegro 5 API
.SH SYNOPSIS
.IP
.EX
#include \f[B]<allegro5/allegro.h>\f[R]

\f[B]typedef\f[R] int32_t al_fixed;
.EE
.SH DESCRIPTION
A fixed point number.
.PP
Allegro provides some routines for working with fixed point numbers, and
defines the type \f[CR]al_fixed\f[R] to be a signed 32\-bit integer.
The high word is used for the integer part and the low word for the
fraction, giving a range of \-32768 to 32767 and an accuracy of about
four or five decimal places.
Fixed point numbers can be assigned, compared, added, subtracted,
negated and shifted (for multiplying or dividing by powers of two) using
the normal integer operators, but you should take care to use the
appropriate conversion routines when mixing fixed point with integer or
floating point values.
Writing \f[CR]fixed_point_1 + fixed_point_2\f[R] is OK, but
\f[CR]fixed_point + integer\f[R] is not.
.PP
The only advantage of fixed point math routines is that you don\[cq]t
require a floating point coprocessor to use them.
This was great in the time period of i386 and i486 machines, but stopped
being so useful with the coming of the Pentium class of processors.
From Pentium onwards, CPUs have increased their strength in floating
point operations, equaling or even surpassing integer math performance.
However, many embedded processors have no FPUs so fixed point maths can
still be useful there.
.PP
Depending on the type of operations your program may need, using
floating point types may be faster than fixed types if you are targeting
a specific machine class.
