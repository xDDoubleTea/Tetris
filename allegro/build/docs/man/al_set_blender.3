.\" Automatically generated by Pandoc 3.1.12.1
.\"
.TH "al_set_blender" "3" "" "Allegro reference manual" ""
.SH NAME
al_set_blender \- Allegro 5 API
.SH SYNOPSIS
.IP
.EX
#include \f[B]<allegro5/allegro.h>\f[R]

void al_set_blender(int op, int src, int dst)
.EE
.SH DESCRIPTION
Sets the function to use for blending for the current thread.
.PP
Blending means, the source and destination colors are combined in
drawing operations.
.PP
Assume the source color (e.g.\ color of a rectangle to draw, or pixel of
a bitmap to draw) is given as its red/green/blue/alpha components (if
the bitmap has no alpha it always is assumed to be fully opaque, so 255
for 8\-bit or 1.0 for floating point): \f[I]s = s.r, s.g, s.b, s.a\f[R].
And this color is drawn to a destination, which already has a color:
\f[I]d = d.r, d.g, d.b, d.a\f[R].
.PP
The conceptional formula used by Allegro to draw any pixel then depends
on the \f[CR]op\f[R] parameter:
.IP \[bu] 2
ALLEGRO_ADD
.RS 2
.IP
.EX
   r = d.r * df.r + s.r * sf.r
   g = d.g * df.g + s.g * sf.g
   b = d.b * df.b + s.b * sf.b
   a = d.a * df.a + s.a * sf.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_DEST_MINUS_SRC
.RS 2
.IP
.EX
   r = d.r * df.r \- s.r * sf.r
   g = d.g * df.g \- s.g * sf.g
   b = d.b * df.b \- s.b * sf.b
   a = d.a * df.a \- s.a * sf.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_SRC_MINUS_DEST
.RS 2
.IP
.EX
   r = s.r * sf.r \- d.r * df.r
   g = s.g * sf.g \- d.g * df.g
   b = s.b * sf.b \- d.b * df.b
   a = s.a * sf.a \- d.a * df.a
.EE
.RE
.PP
Valid values for the factors \f[CR]sf\f[R] and \f[CR]df\f[R] passed to
this function are as follows, where \f[CR]s\f[R] is the source color,
\f[CR]d\f[R] the destination color and \f[CR]cc\f[R] the color set with
al_set_blend_color(3) (white by default)
.IP \[bu] 2
ALLEGRO_ZERO
.RS 2
.IP
.EX
   f = 0, 0, 0, 0
.EE
.RE
.IP \[bu] 2
ALLEGRO_ONE
.RS 2
.IP
.EX
   f = 1, 1, 1, 1
.EE
.RE
.IP \[bu] 2
ALLEGRO_ALPHA
.RS 2
.IP
.EX
   f = s.a, s.a, s.a, s.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_INVERSE_ALPHA
.RS 2
.IP
.EX
   f = 1 \- s.a, 1 \- s.a, 1 \- s.a, 1 \- s.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_SRC_COLOR (since: 5.0.10, 5.1.0)
.RS 2
.IP
.EX
   f = s.r, s.g, s.b, s.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_DEST_COLOR (since: 5.0.10, 5.1.8)
.RS 2
.IP
.EX
   f = d.r, d.g, d.b, d.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_INVERSE_SRC_COLOR (since: 5.0.10, 5.1.0)
.RS 2
.IP
.EX
   f = 1 \- s.r, 1 \- s.g, 1 \- s.b, 1 \- s.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_INVERSE_DEST_COLOR (since: 5.0.10, 5.1.8)
.RS 2
.IP
.EX
   f = 1 \- d.r, 1 \- d.g, 1 \- d.b, 1 \- d.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_CONST_COLOR (since: 5.1.12, not supported on OpenGLES 1.0)
.RS 2
.IP
.EX
   f = cc.r, cc.g, cc.b, cc.a
.EE
.RE
.IP \[bu] 2
ALLEGRO_INVERSE_CONST_COLOR (since: 5.1.12, not supported on OpenGLES
1.0)
.RS 2
.IP
.EX
   f = 1 \- cc.r, 1 \- cc.g, 1 \- cc.b, 1 \- cc.a
.EE
.RE
.PP
Blending examples:
.PP
So for example, to restore the default of using premultiplied alpha
blending, you would use:
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
.EE
.PP
As formula:
.IP
.EX
r = d.r * (1 \- s.a) + s.r * 1
g = d.g * (1 \- s.a) + s.g * 1
b = d.b * (1 \- s.a) + s.b * 1
a = d.a * (1 \- s.a) + s.a * 1
.EE
.PP
If you are using non\-pre\-multiplied alpha, you could use
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA);
.EE
.PP
Additive blending would be achieved with
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ONE);
.EE
.PP
Copying the source to the destination (including alpha) unmodified
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);
.EE
.PP
Multiplying source and destination components
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_DEST_COLOR, ALLEGRO_ZERO)
.EE
.PP
Tinting the source (like al_draw_tinted_bitmap(3))
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_ONE);
al_set_blend_color(al_map_rgb(0, 96, 255)); \f[I]/* nice Chrysler blue */\f[R]
.EE
.PP
Averaging source and destination pixels
.IP
.EX
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
.EE
.PP
As formula:
.IP
.EX
r = d.r * 0 + s.r * d.r
g = d.g * 0 + s.g * d.g
b = d.b * 0 + s.b * d.b
a = d.a * 0 + s.a * d.a
.EE
.SH SEE ALSO
al_set_separate_blender(3), al_set_blend_color(3), al_get_blender(3)
